#region Using directives
using System;
using System.Collections.Generic;
using System.Text;
using System.Web;
using System.IO;
using System.Security.Cryptography;
using System.Configuration;

using log4net;
using System.Web.Hosting;
#endregion

namespace Commanigy.Transmit.Web {
	/// <summary>
	/// 
	/// </summary>
	public class Storage {
		private static ILog log = LogManager.GetLogger("web");

		private static string storageLocation = ReadStorageLocation();

		private static string ReadStorageLocation() {
			string location = Commanigy.Transmit.Data.TransmitSettings.Instance.Setting.StorageLocation;
			if (string.IsNullOrEmpty(location)) {
				return HostingEnvironment.MapPath("~/resources");
			}

			// trim trailing slash
			if (location.EndsWith("/")) {
				location = location.Substring(0, location.Length - 1);
			}

			return location;
		}


		/// <summary>
		/// Saves an uploaded file using specified path prefix (generated by 
		/// client when initial upload is created).
		/// </summary>
		/// <returns></returns>
		public static string SaveFile(string token, HttpPostedFile uploadedFile) {
			// create directory for specific upload (based on unique token)
			string directoryPath = Path.Combine(storageLocation, token);
			Directory.CreateDirectory(directoryPath);

			string filePath = Path.Combine(directoryPath, StripFileName(uploadedFile.FileName));
			
			// TODO: to ensure unique filename do something like this
			//if (File.Exists(filePath)) {
			//    filePath = Path.Combine(Path.GetDirectoryName(filePath), Path.GetFileNameWithoutExtension(filePath) + " (1)" + Path.GetExtension(filePath));
			//}

			uploadedFile.SaveAs(filePath);

			return Path.GetFileName(filePath);
		}


		/// <summary>
		/// 
		/// </summary>
		/// <param name="fileHashes"></param>
		/// <returns></returns>
		public static string GroupFiles(string[] fileHashes) {
			string hash = Guid.NewGuid().ToString("N");
			string path = GetFullDirectoryPath(hash);
			Directory.CreateDirectory(path);
			foreach (string fileHash in fileHashes) {
				string directoryPath = GetFullDirectoryPath(fileHash);
				Directory.Move(directoryPath, Path.Combine(path, fileHash));
			}

			return hash;
		}

		public static string GetFullDirectoryPath(string hash) {
			return Path.Combine(storageLocation, hash);
		}

		public static string GetFullFileNamePath(string hash, string filename) {
			return Path.Combine(GetFullDirectoryPath(hash), filename);
		}

		public static FileInfo[] GetFiles(string hash) {
			string path = GetFullDirectoryPath(hash);
			if (!Directory.Exists(path)) {
				return new FileInfo[0];
			}

			List<FileInfo> files = new List<FileInfo>();

			string[] pathFiles = Directory.GetFiles(path);
			foreach (var filename in pathFiles) {
				files.Add(new FileInfo(filename));
			}

			return files.ToArray();
		}


		/// <summary>
		/// Delete entire package directory (including all files it might contain)
		/// </summary>
		/// <param name="hash"></param>
		/// <returns></returns>
		public static bool DeletePath(string hash) {
			string path = GetFullDirectoryPath(hash);

			try {
				if (Directory.Exists(path)) {
					Directory.Delete(path, true);
				}

				// might have a .zip package as well we need to clean
				path = path + ".zip";
				if (File.Exists(path)) {
					File.Delete(path);
				}

				return true;
			}
			catch (IOException x) {
				log.Error(string.Format("Failed to delete path \"{0}\"", path), x);
			}
			catch (UnauthorizedAccessException uax) {
				log.Error(string.Format("Unauthorized access while deleting \"{0}\"", path), uax);
			}

			return false;
		}


		/// <summary>
		/// 
		/// </summary>
		/// <param name="p"></param>
		/// <param name="fileHash"></param>
		/// <returns></returns>
		/// 

		public static long GetFileSize(string packageCode, string fileHash) {
			string path = GetFullFileNamePath(packageCode, fileHash);
			if (!File.Exists(path)) {
				log.WarnFormat("Expected file {0} not found so no filesize could be written", path);
				return -1;
			}

			return new FileInfo(path).Length;
		}

		/// <summary>
		/// Gets a list of all available directories.
		/// </summary>
		/// <returns>List of directory names (not full paths); empty list if none exists</returns>
		public static string[] GetDirectories() {
			return Array.ConvertAll(Array.FindAll(Directory.GetDirectories(storageLocation), FilterByDate), new Converter<string, string>(TrimPath));
		}

		protected static string TrimPath(string path) {
			return Path.GetFileName(path);
		}

		/// <summary>
		/// Filter paths newer than one day.
		/// </summary>
		/// <param name="path"></param>
		/// <returns></returns>
		protected static bool FilterByDate(string path) {
			return DateTime.UtcNow.AddDays(-1) > Directory.GetCreationTimeUtc(path);
		}

		protected static string StripFileName(string filename) {
			return filename.Replace(",", "-");
		}

		//private const string CHARACTERS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

		//static public long Decode(string value) {
		//    List<char> database = new List<char>(CHARACTERS);
		//    List<char> tmp = new List<char>(value.ToUpper().TrimStart(new char[] { '0' }).ToCharArray());
		//    tmp.Reverse();

		//    long number = 0;
		//    int index = 0;
		//    foreach (char character in tmp) {
		//        number += database.IndexOf(character) * (long)Math.Pow(36, index);
		//        index++;
		//    }

		//    return number;
		//}
		  
		//static public string Encode(long number) {
		//    List<char> database = new List<char>(CHARACTERS);
		//    List<char> value = new List<char>();
		//    long tmp = number;

		//    while (tmp != 0) {
		//        value.Add(database[Convert.ToInt32(tmp % 36)]);
		//        tmp /= 36;
		//    }

		//    value.Reverse();
		//    return new string(value.ToArray());
		//}


		public static void PurgeDirectories(string[] availableDirectories) {
			foreach (var packageCode in availableDirectories) {
				Storage.DeletePath(packageCode);
			}
		}

		public static void Pack(string packageCode) {
			string path = Storage.GetFullDirectoryPath(packageCode);

			ICSharpCode.SharpZipLib.Zip.FastZip fz = new ICSharpCode.SharpZipLib.Zip.FastZip();
			fz.CreateZip(path + ".zip", path, true, "", "");

			// remove directory after zipping
			try {
				if (Directory.Exists(path)) {
					Directory.Delete(path, true);
				}
			}
			catch (Exception x) {
				log.Error("Unable to delete directory after successfully having zipped it", x);
			}
		}


		public static string GetUniqueName(string directoryPath, string fileName) {
			string originalName = fileName.Substring(0, fileName.LastIndexOf("."));
			string originalExt = fileName.Substring(fileName.LastIndexOf(".") + 1);

			string returnName = fileName;
			int increment = 1;
			while (File.Exists(Path.Combine(directoryPath, returnName))) {
				returnName = originalName + string.Format(" ({0})", increment++) + "." + originalExt;
			}

			return returnName;
		}
	}
}